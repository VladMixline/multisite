import { useState } from 'react'
import { Link } from 'react-router-dom'
import './Chapter2.css'

function Chapter2() {
  const [showQuestions, setShowQuestions] = useState(false)
  
  const questions = [
    "Какова роль лексического анализатора?",
    "Что такое лексемы?",
    "Каким этапом компиляции является синтаксический анализ?",
    "Какими бывают методы синтаксического анализа?",
    "Какой этап предшествует синтаксическому анализу?",
    "Что означает данная запись <список переменных> → ид{,ид}?",
    "Конечными символами грамматического дерева являются …",
    "В каком виде лексический анализатор должен представлять исходный текст?",
    "Во время какого этапа предложения распознаются как языковые конструкции используемой грамматики?",
    "Этот метод относится к восходящим, которые начинают разбор с конечных узлов грамматического дерева и пытаются объединить их построением узлов всё более и более высокого уровня до тех пор, пока не будет достигнут корень дерева.",
    "В методе операторного предшествования переименование нетерминальных символов возможно?",
    "Чем отличаются способы нисходящего и восходящего грамматического разбора?",
    "Какие известны методы синтаксического анализа?",
    "В чём сущность метода рекурсивного спуска?",
    "Для чего применяется изменённый способ записи БНФ?",
    "В каком виде представляется программа на выходе синтаксического анализатора?",
    "В чём сущность метода операторного предшествования?",
    "Запись, в которой знак операции ставится непосредственно за операндами, называется...",
    "Сколько возможно форм объектного кода?",
    "В какой форме объектного кода не приходится формировать команды как последовательности битов; можно порождать команды, содержащие символические имена?",
    "Почему программу на автокоде считают наихудшим из вариантов?",
    "В генерации кода для постфиксной записи для указания вершины стека обычно используют индекс i. Какое значение i перед чтением стека будет означать, что стек пуст?"
  ]

  return (
    <div className="chapter2">
      <div className="container">
        <nav className="breadcrumb">
          <Link to="/">Главная</Link> / 2. ТЕОРИЯ ТРАНСЛЯЦИИ
        </nav>
        
        <h1>2. ТЕОРИЯ ТРАНСЛЯЦИИ</h1>
        
        <div className="chapter-plan">
          <h2>План:</h2>
          <ol>
            <li>Лексический анализ.</li>
            <li>Синтаксический анализ.</li>
            <li>Метод рекурсивного спуска.</li>
            <li>Метод операторного предшествования.</li>
            <li>Внутреннее представление программы.</li>
            <li>Генерация кода.</li>
          </ol>
          <p className="keywords">
            <strong>Ключевые слова:</strong> трансляция, синтаксический анализ, постфиксная запись, внутреннее представление в виде четвёрок.
          </p>
        </div>

        <section className="chapter-section">
          <h2>2.1. ЛЕКСИЧЕСКИЙ АНАЛИЗ</h2>
          <p>
            На вход компилятора, а следовательно, и лексического анализатора поступает цепочка символов некоторого алфавита. Работа лексического анализатора заключается в том, чтобы сгруппировать определённые символы в единые синтаксические объекты, называемые лексемами. Какие объекты считать лексемами, зависит от определения языка. Кроме терминальных символов (+, –, /, *, (,)), которые сами по себе являются лексемами, в программе некоторые комбинации символов часто рассматриваются как единые объекты. Среди типичных примеров можно указать следующие:
          </p>
          <ul>
            <li>В некоторых языках цепочка, состоящая из одного или более пробелов, обычно рассматривается как один пробел.</li>
            <li>В языках программирования есть ключевые слова, такие как begin, end, to, do, integer и др., каждое из которых считается одним символом.</li>
            <li>Каждая цепочка, представляющая цифровую константу, рассматривается как один элемент текста.</li>
            <li>Идентификаторы, используемые имена переменных, функций, процедур, меток и т.п. также считаются лексическими единицами алгоритмического языка.</li>
          </ul>
          <p>
            Для программы на рис. 1 будем считать лексемами терминальные символы, относящиеся к ключевым словам, знакам операций, разделителям (program, var, begin, integer, end, (,), :=, +, –, *, div, read, for, write, to, do, :, ; , .). Кроме того, возможны лексемы – идентификаторы и константы.
          </p>
          <p>
            Итак, лексический анализатор должен исходный текст программы (рис. 1) представить в виде последовательности лексем. Для эффективности последующих действий каждая лексема обычно представляется некоторым кодом фиксированной длины (например, целым числом), а не в виде строки символов переменной длины.
          </p>
          <div className="image-container">
            <img src="/images/таблица 1.png" alt="Таблица 1" className="chapter-image" />
            <p className="image-caption">Таблица 1</p>
          </div>
          <p>
            Для вышеприведённого примера можно составить кодировочную таблицу (табл. 1). Если распознанная лексема является ключевым словом, разделителем или знаком операции, такая схема кодирования даёт всю необходимую информацию. В случае идентификатора или константы необходимы дополнительные данные (в простейшем случае – тип и указание на адрес ячейки памяти, где они хранятся). Обычно эти данные находятся в таблицах символов и в качестве дополнительной информации для лексемы типа идентификатор или константа может служить указатель на соответствующий элемент таблицы.
          </p>
          <div className="image-container">
            <img src="/images/таблица 2.png" alt="Таблица 2" className="chapter-image" />
            <p className="image-caption">Таблица 2</p>
          </div>
          <p>
            Таким образом, результат обработки лексическим анализатором обрабатываемой программы можно представить последовательностью лексем (табл. 2). Здесь в качестве дополнительных данных для констант используется значение самой константы, а для идентификатора – его номер в таблице символов.
          </p>
        </section>

        <section className="chapter-section">
          <h2>2.2. СИНТАКСИЧЕСКИЙ АНАЛИЗ</h2>
          <p>
            Синтаксический анализ – второй этап компиляции. Во время этого этапа предложения программы распознаются как языковые конструкции используемой грамматики. Для того, чтобы выяснить, принадлежит ли предложение языку, необходимо построить алгоритм, который для любого предложения, допустимого грамматикой, давал бы последовательность выводов этой цепочки к начальному символу грамматики. Мы можем рассматривать этот процесс как построение дерева грамматического разбора для транслируемых предложений. Различают две категории алгоритмов разбора: нисходящий (сверху вниз) и восходящий (снизу вверх). Эти термины соответствуют способу построения синтаксических деревьев. Рассмотрим для примера предложение 35 в грамматике целых чисел:
          </p>
          <p className="code-example">
            N → В/NВ; В → 0/1/2/3/4/5/6/7/8/9.
          </p>
          <p>
            При нисходящем разборе дерево строится от корня (начального символа) вниз к концевым узлам (рис. 4).
          </p>
          <p>
            Восходящий разбор состоит в том, что, отправляясь от заданной цепочки, пытаются привести её к начальному символу (рис. 5).
          </p>
          <div className="image-container">
            <img src="/images/рис 4.png" alt="Рисунок 4" className="chapter-image" />
            <p className="image-caption">Рис. 4</p>
          </div>
          <div className="image-container">
            <img src="/images/рис 5.png" alt="Рисунок 5" className="chapter-image" />
            <p className="image-caption">Рис. 5</p>
          </div>
          <p>
            Разработано множество методов синтаксического анализа. В лабораторных работах рассматриваются два метода: нисходящий и восходящий.
          </p>
        </section>

        <section className="chapter-section">
          <h2>2.3. МЕТОД РЕКУРСИВНОГО СПУСКА</h2>
          <p>
            Процесс грамматического разбора для этого метода состоит из отдельных процедур для каждого нетерминального символа, определённого в грамматике. Каждая такая процедура старается во входном потоке найти подстроку, начинающуюся с текущей лексемы, которая может быть интерпретирована как нетерминальный символ, связанный с данной процедурой. В процессе своей работы она может вызывать другие процедуры или даже рекурсивно саму себя для поиска других нетерминальных символов. Если эта процедура находит соответствующий нетерминальный символ, то она заканчивает работу и передаёт в вызывающую её программу признак успешного выполнения. Затем рассматривается следующая лексема, идущая за распознанной подстрокой. Если же процедура не может найти подстроку, которая могла бы быть интерпретирована как требуемый нетерминальный символ, она заканчивается с признаком неудачи или же вызывает процедуру диагностического сообщения.
          </p>
          <p>
            Рассмотрим в качестве примера правило грамматики:
          </p>
          <p className="code-example">
            &lt;ввод&gt; → read (&lt;список переменных&gt;)
          </p>
          <p>
            Процедура метода рекурсивного спуска, соответствующая нетерминальному символу &lt;ввод&gt;, прежде всего исследует две последовательные лексемы "read" и "(". В случае совпадения эта процедура вызывает другую процедуру, соответствующую нетерминальному символу &lt;список переменных&gt;. Если эта процедура закончится успешно, то процедура &lt;ввод&gt; сравнивает следующую лексему с ")". Если все эти проверки окажутся успешными, то процедура &lt;ввод&gt; завершается с признаком успеха и устанавливает указатель текущей лексемы на лексему, следующую за ")".
          </p>
          <p>
            Ещё пример. Процедура, соответствующая нетерминальному символу &lt;оператор&gt;, анализирует очередную лексему для того, чтобы выбрать одну из четырёх альтернатив:
          </p>
          <p className="code-example">
            &lt;оператор&gt; → &lt;присваивание&gt;/&lt;ввод&gt;/&lt;вывод&gt;/&lt;цикл&gt;
          </p>
          <p>
            Если это лексема read, то вызывается процедура &lt;ввод&gt;. Если это лексема, соответствующая символу идентификатор, то вызывается процедура &lt;присваивание&gt;, поскольку это единственная альтернатива, которая может начинаться с лексемы идентификатор, и т.д.
          </p>
          <p>
            Но если мы попытаемся написать полный набор процедур для грамматики, то столкнёмся со следующей трудностью – процедура для нетерминала &lt;список переменных&gt; будет не в состоянии выбрать одну из двух альтернатив, поскольку обе альтернативы: ид и &lt;список переменных&gt; могут начинаться с лексемы ид.
          </p>
          <p className="code-example">
            &lt;список переменных&gt; → ид / &lt;список переменных&gt;, ид
          </p>
          <p>
            Тут скрыта и более существенная трудность. Если процедура каким-либо образом решит попробовать альтернативу &lt;список переменных&gt;/ ид, то она немедленно вызовет рекурсивно саму себя для поиска нетерминального символа &lt;список переменных&gt;. Это приведёт ещё к одному рекурсивному вызову и т.д., в результате чего образуется бесконечная цепочка рекурсивных вызовов. Те же проблемы возникнут и для некоторых других правил грамматики (&lt;раздел переменных&gt;, &lt;раздел операторов&gt;, &lt;арифметическое выражение&gt;, &lt;слагаемое&gt;). Как избежать такой рекурсии? Для этого применяют другую запись грамматики. Например:
          </p>
          <p className="code-example">
            &lt;список переменных&gt; → ид {'{'}, ид{'}'}
          </p>
          <p>
            Эта запись, являющаяся широко принятым расширением БНФ, означает, что конструкция, заключённая в фигурные скобки, может быть либо опущена, либо повторяться один или более число раз. Таким образом, это правило определяет нетерминальный символ &lt;список переменных&gt; как состоящий из единственной лексемы ид или же из произвольного числа следующих друг за другом лексем ид, разделённых запятой. Это, бесспорно, эквивалентно ранее принятому правилу. В соответствии с этим новым определением процедура &lt;список переменных&gt; сначала ищет лексему ид, а затем продолжает сканировать входной текст до тех пор, пока следующая пара лексем не совпадёт с запятой и ид. Такая запись устраняет проблему рекурсии, а также решает вопрос выбора из двух альтернатив.
          </p>
          <p>
            Грамматика языка, к которому принадлежит предложение (рис. 1), имеет вид, представленный на рис. 6.
          </p>
          <div className="image-container">
            <img src="/images/рис 6.png" alt="Рисунок 6" className="chapter-image" />
            <p className="image-caption">Рис. 6</p>
          </div>
          <p>
            Рассмотрим примеры алгоритмов синтаксического анализа методом рекурсивного спуска для некоторых предложений исходной программы с использованием приведённой грамматики.
          </p>
          <p>
            Имеем предложение исходной программы: READ (a).
          </p>
          <p>
            Тогда процедура разбора этого предложения может иметь вид:
          </p>
          <div className="code-block">
            <pre>{`procedure <ввод>;
begin
  BP := false;
  if t = read then begin
    перейти к следующей лексеме;
    if t = ( then begin
      перейти к следующей лексеме;
      if <список переменных> закончилась успешно then
        if t = ) then begin
          BP := true;
          перейти к следующей лексеме;
        end; {if )}
    end; {if (}
  end; {if read}
  if BP = true then успешное завершение
  else неудачное завершение;
end;`}</pre>
          </div>
          <p>
            В приведённой процедуре BP – вспомогательная переменная, а t – переменная, определяющая тип лексемы. Процедура, соответствующая нетерминальному символу &lt;ввод&gt;, вызывает процедуру &lt;список переменных&gt;:
          </p>
          <div className="code-block">
            <pre>{`procedure <список переменных>;
begin
  BP := false;
  if t=ид then begin
    BP := true;
    перейти к следующей лексеме;
    while ( t = , ) and ( BP = true ) do begin
      перейти к следующей лексеме;
      if t = ид then перейти к следующей лексеме
      else BP := false;
    end; {while}
    if BP = true then успешное завершение
    else неудачное завершение;
  end;
end;`}</pre>
          </div>
          <p>
            На рисунке 7 графически представлен процесс грамматического разбора методом рекурсивного спуска для предложения READ. На рисунке 7, а изображен вызов процедуры &lt;ввод&gt;, которая обнаружила лексемы READ и ) во входном потоке (штриховая линия). На рисунке 7, б процедура &lt;ввод&gt; вызывает процедуру &lt;список переменных&gt; (сплошная линия), которая обработала лексему ид. На рисунке 7, в процедура &lt;список переменных&gt; закончила работу, передала управление процедуре &lt;ввод&gt; с признаком успешного завершения; процедура &lt;ввод&gt; обработала входную лексему ). На этом анализ входного предложения завершён.
          </p>
          <div className="image-container">
            <img src="/images/рис 7.png" alt="Рисунок 7" className="chapter-image" />
            <p className="image-caption">Рис. 7</p>
          </div>
          <p>
            Приведём ещё один пример. Имеем предложение из исходной программы:
          </p>
          <p className="code-example">
            rez := sum div 100 – A * A.
          </p>
          <p>
            Представим алгоритмы разбора этого предложения методом рекурсивного спуска:
          </p>
          <div className="code-block">
            <pre>{`procedure <присваивание>
begin
  BP := false;
  if t = ид then begin
    перейти к следующей лексеме;
    if t = := then begin
      перейти к следующей лексеме;
      if <арифметическое выражение> завершилось успешно then
        BP := true;
    end; {if :=}
  end; {if ид.}
  if BP = true then успешное завершение
  else неудачное завершение;
end;`}</pre>
          </div>
          <p>
            Процедура присваивание в процессе работы вызывает процедуру &lt;арифметическое выражение&gt;:
          </p>
          <div className="code-block">
            <pre>{`procedure арифметическое выражение;
begin
  BP:=false;
  if <слагаемое> завершилось успешно then begin
    BP:=true;
    while (t = + или t = - ) and ( BP=true ) do begin
      Перейти к следующей лексеме;
      if <слагаемое> завершилось неудачно then BP:=false;
    end; {while}
  end; {if слагаемое}
  if BP = true then успешное завершение
  else неудачное завершение;
end;`}</pre>
          </div>
          <p>
            Процедура &lt;арифметическое выражение&gt; в соответствии с грамматикой вызывает процедуру &lt;слагаемое&gt;:
          </p>
          <div className="code-block">
            <pre>{`procedure <слагаемое>;
begin
  BP:=false;
  if <значение> завершилось успешно then begin
    BP:=true;
    while (t = * или t = div ) and ( BP=true ) do begin
      Перейти к следующей лексеме;
      if <значение> завершилось неудачно then BP:=false;
    end; {while}
  end; {if значение}
  if BP=true then успешное завершение
  else неудачное завершение;
end;`}</pre>
          </div>
          <p>
            И, наконец, процедура &lt;слагаемое&gt; вызывает процедуру &lt;значение&gt;, которая распознает переменные, константы или вызывает процедуру &lt;арифметическое выражение&gt;.
          </p>
          <p>
            Мы привели примеры грамматического разбора отдельных предложений методом рекурсивного спуска. Однако этот метод применим и ко всей программе в целом. В этом случае для осуществления синтаксического анализа следует просто обратиться к процедуре, соответствующей нетерминальному символу &lt;программа&gt;.
          </p>
          <p>
            В результате работы этой процедуры будет построено дерево грамматического разбора для всей программы.
          </p>
        </section>

        <section className="chapter-section">
          <h2>2.4. МЕТОД ОПЕРАТОРНОГО ПРЕДШЕСТВОВАНИЯ</h2>
          <p>
            Этот метод относится к восходящим (метод снизу вверх), которые начинают разбор с конечных узлов грамматического дерева и пытаются объединить их построением узлов всё более и более высокого уровня до тех пор, пока не будет достигнут корень дерева. Метод операторного предшествования основан на анализе пар последовательно расположенных операторов исходной программы и решением вопроса о том, какой из них должен выполняться первым. Рассмотрим, например, арифметическое выражение
          </p>
          <p className="code-example">
            А + В*С – В.
          </p>
          <p>
            В соответствии с обычными правилами арифметики умножение и деление осуществляются до сложения и вычитания. Можно сказать, что умножение и деление имеют более высокий уровень предшествования, чем сложение и вычитание. При анализе первых двух операторов (+,*) выяснится, что оператор + имеет более низкий уровень предшествования, чем оператор *. Часто это записывают следующим образом:
          </p>
          <p className="code-example">
            + &lt;• *
          </p>
          <p>
            Аналогично для следующей пары операторов (* и –) оператор * имеет более высокий уровень предшествования, чем оператор –. Мы можем записать это в виде
          </p>
          <p className="code-example">
            * •&gt; –
          </p>
          <p>
            Метод операторного предшествования использует подобные отношения между операторами для управления процессом грамматического разбора. В частности, для рассмотренного арифметического выражения мы получили следующие отношения предшествования:
          </p>
          <p className="code-example">
            А + В*С – В<br />
            &lt;• •&gt;
          </p>
          <p>
            Отсюда следует, что подвыражение В*С должно быть вычислено до обработки любых других операторов рассматриваемого выражения. В терминах дерева грамматического разбора это означает, что операция * расположена на более низком уровне узлов дерева, чем операция + или –. Таким образом, рассматриваемый метод грамматического разбора должен распознать конструкцию В*С, интерпретируя её в терминах заданной грамматики, до анализа соседних термов предложения.
          </p>
          <p>
            Предшествующее изложение иллюстрирует основную идею, на которой основан метод грамматического разбора, построенный на отношениях операторного предшествования. В рамках этого метода предложение сканируется слева направо до тех пор, пока не будет найдено подвыражение, операторы которого имеют более высокий уровень предшествования, чем соседние операторы. Далее это подвыражение распознаётся в терминах правил вывода используемой грамматики. Этот процесс продолжается до тех пор, пока не будет достигнут корень дерева, что и будет означать окончание процесса грамматического разбора. Далее мы рассмотрим приложение описанного подхода к нашему примеру программы (рис. 1). Грамматика этого предложения имеет вид, представленный на рис. 2.
          </p>
          <p>
            Первым шагом при разработке процессора грамматического разбора, основанного на методе операторного предшествования, должно быть установление отношений предшествования между операторами грамматиками. При этом под оператором понимается любой терминальный символ (т.е. любая лексема). Таким образом, мы должны, в частности, установить отношения предшествования между лексемами begin, read, (. Приведём матрицу, которая задаёт отношения предшествования для нашей грамматики (табл. 4).
          </p>
          <div className="image-container">
            <img src="/images/таблица 4.png" alt="Таблица 4" className="chapter-image" />
            <p className="image-caption">Таблица 4</p>
          </div>
          <p>
            Каждая клетка этой матрицы определяет отношение предшествования (если оно существует) между лексемами, соответствующими строке и столбцу, на пересечении которых находится эта клетка. Например, мы видим, что
          </p>
          <p className="code-example">
            program = var и<br />
            begin &lt;• read
          </p>
          <p>
            Отношение = означает, что обе лексемы имеют одинаковый уровень предшествования и должны рассматриваться грамматическим процессором в качестве составляющих одной конструкции языка. Обратите внимание, что для отношения предшествования не выполняются некоторые правила, привычные для отношения арифметического порядка. Например,
          </p>
          <p className="code-example">
            ; •&gt; end, но end •&gt; ;
          </p>
          <p>
            Обратите внимание также на то, что для многих пар лексем отношения предшествования не существует. Это означает, что соответствующие пары лексем не могут находиться рядом ни в каком грамматически правильном предложении. Если подобная комбинация лексем всё же встретится в процессе грамматического разбора, то она должна рассматриваться как синтаксическая ошибка.
          </p>
          <p>
            Для применимости метода операторного предшествования необходимо, чтобы отношения предшествования были заданы однозначно, например, не должно быть одновременно отношений ; &lt;• begin и ; &gt;• begin. Это требование выполняется для нашей грамматики, однако, несущественные её изменения могут привести к тому, что некоторые из отношений перестанут быть однозначными и метод операторного предшествования станет не применимым.
          </p>
          <p>
            Приведём пример разбора с помощью операторного предшествования. Пусть анализируется предложение read из нашей программы. Это предложение анализируется по лексемам слева направо. Для каждой пары соседних операторов определено отношение предшествования
          </p>
          <div className="code-block">
            <pre>{`begin read  (  ид  )  ;
<•  =  <•.      •>  •>
begin read ( <N1> )  ;
<•  =        =     •>
begin  <N2>        ;
<•`}</pre>
          </div>
          <p>
            На первом шаге процессор грамматического разбора выделим фрагмент, ограниченный отношениями &lt;• и •&gt; для распознавания в терминах грамматики. В данном случае этот фрагмент содержит единственную лексему ид. Эта лексема может быть распознана как нетерминал &lt;значение&gt; в соответствии с правилом из грамматики. Однако эта лексема может быть также распознана как нетерминальный символ &lt;список переменных&gt;. Для рассматриваемого метода не важно, какой конкретно нетерминальный символ распознан. Лексема ид интерпретируется просто как некий нетерминальный символ &lt;N1&gt;. Конструкция read(&lt;N1&gt;) интерпретируется как один нетерминальный символ &lt;N2&gt;.
          </p>
          <p>
            На этом разбор предложения READ закончено. Если мы сравним деревья грамматического разбора для этого предложения, то увидим, что они полностью совпадают, за исключением имён нетерминальных символов.
          </p>
          <p>
            Рассмотрим грамматический разбор для оператора
          </p>
          <div className="code-block">
            <pre>{`;  rez: = sum div 100 - А * А ;
<  = <  >  <  > < > < >
;  rez := <N1> div <N2> - <N4> * <N5> ;
<  =  <  >  <  >
;  rez := <N3> - <N6> ;
<  =  <  >
;  rez := <N7> ;
<  =  >`}</pre>
          </div>
          <p>
            При этом дерево грамматического разбора имеет вид, представленный на рис. 12.
          </p>
          <div className="image-container">
            <img src="/images/рис 12.png" alt="Рисунок 12" className="chapter-image" />
            <p className="image-caption">Рис. 12</p>
          </div>
          <p>
            Заметим ещё раз, что процесс грамматического разбора начинается слева направо и продолжается на каждом шаге до тех пор, пока не определится очередной фрагмент предложения для грамматического распознавания, т.е. первый фрагмент, ограниченный отношениями &lt;• и •&gt;. Как только подобный фрагмент выделен, он интерпретируется как некоторый очередной нетерминальный символ в соответствии с каким-нибудь правилом грамматики. Этот процесс продолжается до тех пор, пока предложение не будет распознано целиком.
          </p>
          <p>
            Обратите внимание, что каждый фрагмент дерева грамматического разбора строится, начиная с конечных узлов, вверх, в сторону корня дерева. Отсюда и возник термин восходящий разбор. Если мы рассмотрим дерево грамматического разбора, исходя из грамматики языка (рис. 2), то увидим, что оно несколько отличается от полученного методом операторного предшествования дерева (рис. 12).
          </p>
          <p>
            Например, идентификатор sum был сначала интерпретирован как &lt;значение&gt;, а потом как &lt;слагаемое&gt;, являющийся одним из операндов операции div. При разборе методом операторного предшествования идентификатор sum был интерпретирован как единственный нетерминал &lt;N1&gt;, который является операндом операции div. Таким образом, &lt;N1&gt; соответствует двум нетерминальным символам &lt;значение&gt; и &lt;слагаемое&gt;. Имеются и другие подобные различия.
          </p>
          <p>
            Они вытекают из свободы образования имен нетерминальных символов, распознаваемых в рамках метода операторного предшествования. Интерпретация sum сначала как &lt;значение&gt;, а потом как &lt;слагаемое&gt; является просто переименованием нетерминальных символов. Такое переименование необходимо, поскольку в соответствии с грамматикой (правило 8) первым операндом операции умножения должен быть &lt;слагаемое&gt;, а не &lt;значение&gt;, так как для нашего метода имена нетерминальных символов несущественны, то подобные переименования становятся ненужными. Собственно говоря, три различных имени: &lt;арифметическое выражение&gt;, &lt;слагаемое&gt;, &lt;значение&gt; – были включены в грамматику только как средства описания отношения предшествования между операторами (например, для указания того, что умножение следует выполнять после сложения). Поскольку эта информация содержится в нашей матрице предшествования, то становится ненужным различать эти три имени в процессе грамматического разбора.
          </p>
          <p>
            Возможный алгоритм метода операторного предшествования приведён на рис. 13.
          </p>
          <div className="image-container">
            <img src="/images/рис 13.png" alt="Рисунок 13" className="chapter-image" />
            <p className="image-caption">Рис. 13</p>
          </div>
          <p>
            В данном алгоритме первоначально просматривается цепочка лексем (массив L), устанавливается отношение предшествования между соседними лексемами по таблице отношений предшествования (матрица M[nxn]) до тех пор, пока не встретится отношение '&gt;' (блоки 4 – 5). После этого возвращаемся по массиву лексем назад, пока между лексемами не встретится отношение '&lt;' (блоки 7 – 8). Затем лексемы, ограниченные отношениями '&lt; &gt;', записываются во внутреннее представление (блоки 9 – 10). В блоках 12 – 14 элементы массива лексем сдвигаются на длину выведенной цепочки. Так продолжается, пока не распознана вся последовательность лексем.
          </p>
        </section>

        <section className="chapter-section">
          <h2>2.5. ВНУТРЕННЕЕ ПРЕДСТАВЛЕНИЕ ПРОГРАММЫ</h2>
          <p>
            На выходе синтаксического анализатора формируется программа во внутреннем представлении. Существует несколько различных способов представления программы в некоторой промежуточной форме для анализа и оптимизации кода: последовательность четвёрок, последовательность троек, постфиксная запись, префиксная запись, синтаксическое дерево.
          </p>
          <h3>1. Последовательность четвёрок</h3>
          <p>
            Каждая четвёрка записывается в виде:
          </p>
          <p className="code-example">
            операция ор1, ор2, результат,
          </p>
          <p>
            где операция – выполняемая объектным кодом функция; ор1, ор2 – операнды этой операции; результат определяет, куда должно быть помещено результирующее значение.
          </p>
          <p>
            Например, предложение исходной программы (рис. 1): sum:=sum+а может быть представлено четвёрками следующим образом:
          </p>
          <div className="code-block">
            <pre>{`+  sum , а ,  I1
:= I1 ,  ,  sum`}</pre>
          </div>
          <p>
            Здесь I1 обозначает промежуточный результат (sum+а), вторая четвёрка присваивает это значение переменной sum.
          </p>
          <p>
            Все четвёрки расположены в том порядке, в котором должны выполняться соответствующие инструкции объектного кода, что существенно облегчает анализ для оптимизации кода. Это означает также, что трансляция в машинные коды будет относительно простой. В таблице 3 представлена последовательность четвёрок, соответствующая исходной программе.
          </p>
          <div className="image-container">
            <img src="/images/таблица 5.png" alt="Таблица 3" className="chapter-image" />
            <p className="image-caption">Таблица 3</p>
          </div>
          <p>
            За операциями read и write следует четвёрка Param, определяющая параметры операций read и write. Четвёрка Param будет, разумеется, при окончательной генерации машинного кода оттранслирована в список параметров. Операция &gt; в четвёрке 3 сравнивает значение двух своих операндов и осуществляет переход к четвёрке 9, если первый операнд больше второго. Операция goto в четвёрке 8 осуществляет безусловный переход к четвёрке 3.
          </p>
          <p>
            Таким образом, последовательность четвёрок и является результатом работы синтаксического анализатора.
          </p>
          <h3>2. Постфиксная запись</h3>
          <p>
            Обычно программа осуществляет те или иные действия над данными. Соответствующие операции программист записывает, используя инфиксную форму записи, в которой знак операции ставится между операндами. Например: ( А + В ) * С.
          </p>
          <p>
            Вычисление такого выражения является непростой задачей. Операцию умножения нельзя выполнить до тех пор, пока не будет прочитан второй операнд С. Если этот операнд сам является сложным выражением, то прежде чем выполнить умножение, необходимо считать много данных из текста программы.
          </p>
          <p>
            Отмеченные трудности можно легко обойти, если использовать другую форму записи операций. Она называется постфиксной и отличается тем, что знак операции ставится непосредственно за операндами. Такая запись обладает двумя ценными свойствами, благодаря которым её используют как промежуточную форму представления исходной программы при трансляции:
          </p>
          <ol>
            <li>Для записи любого выражения не нужны скобки. Так как оператор непосредственно следует за операндами, участвующими в операции, неопределённость в указании операндов отсутствует. Например, выражение ( А + В ) * С в постфиксной записи имеет вид: А В + С *.</li>
            <li>К моменту считывания очередного оператора соответствующие операнды уже прочитаны. Поэтому оператор может быть выполнен без чтения каких либо дополнительных данных.</li>
          </ol>
          <p>
            Сказанное выше относится к бинарным операциям, однако не трудно распространить результаты рассуждений и на унарные операции. Однако при этом могут возникнуть сложности. Например, знак " – " может стоять в инфиксной записи, указывая как бинарную, так и унарную операцию, и его правильный смысл становится очевидным из контекста. В постфиксной записи сделать это труднее. Унарный минус и другие унарные операции можно представлять двумя способами: либо записывать их как бинарные операции, например вместо " – В " писать " 0 – В "; либо для обозначения унарных операций вводить новый символ, например, выражение А + ( – В + С * Е ) в постфиксной форме примет вид: А В @ С Е * + + .
          </p>
        </section>

        <section className="chapter-section">
          <h2>2.6. ГЕНЕРАЦИЯ КОДА</h2>
          <p>
            Возможны три формы объектного кода: абсолютные команды, помещённые в фиксированные ячейки (после окончания компиляции такая программа немедленно выполняется); программа на автокоде (ее потом придётся транслировать); программа на языке машины, записанная на внешнюю память (для выполнения она должна быть объединена с другими подпрограммами и затем загружена).
          </p>
          <p>
            Первый вариант наиболее экономичен в отношении расходуемого времени. Главный недостаток этого варианта состоит в том, что нельзя предварительно и независимо протранслировать несколько подпрограмм и затем объединить их вместе для выполнения, все подпрограммы должны транслироваться одновременно. Выигрыш во времени оборачивается проигрышем в гибкости. Проще всего получить объектную программу на автокоде. В этом случае не приходится формировать команды как последовательности битов; можно порождать команды, содержащие символические имена. Более того, можно формировать макроопределение. Это позволяет также уменьшить объём компилятора. Несмотря на очевидные достоинства, трансляция на автокод обычно считается наихудшим из вариантов. И в самом деле, к процессу трансляции добавляется ещё один шаг, который часто требует столько же времени, сколько длится собственно компиляция.
          </p>
          <p>
            Большинство промышленных компиляторов вырабатывают объектную программу в виде объектного модуля. Как правило, объектный модуль содержит символические имена других программ (подпрограмм), к которым он обращается, и имена своих входных точек, к которым можно обращаться из других программ. Эта объектная программа "объединяется" с теми другими объектными программами, а затем загружается в некоторую область памяти для выполнения.
          </p>
          <p>
            В этом варианте обеспечивается гораздо большая гибкость, и поэтому во многих системах он и принят в качестве стандартной процедуры. Следует, однако, заметить, что на объединение и загрузку также расходуется время.
          </p>
          <p>
            Теперь покажем, как генерируются команды для последовательности четвёрок и постфиксной записи, используя в качестве примера выражение
          </p>
          <p className="code-example">
            А * ((А * В + С) – С * В).
          </p>
          <p>
            Будем считать переменные А, В, С, В целыми. Генерация кода для последовательности четвёрок.
          </p>
          <p>
            Для рассматриваемого примера последовательность четвёрок имеет вид:
          </p>
          <div className="code-block">
            <pre>{`*  A  B  I1
+  I1  C  I2
*  C  D  I3
-  I2  I3  I4
*  A  I4  I5`}</pre>
          </div>
          <p>
            В основе процедуры генерации кода лежит оператор case:
          </p>
          <div className="code-block">
            <pre>{`procedure ГК;
case код операции четвёрки of
  * : подпрограмма, соответствующая операции *;
  + : подпрограмма, соответствующая операции +;
  - : подпрограмма, соответствующая операции -;
end;`}</pre>
          </div>
          <p>
            Генерация кода для постфиксной записи. Для рассматриваемого примера постфиксная запись имеет вид:
          </p>
          <p className="code-example">
            A A B * C + C D * – A *.
          </p>
          <p>
            Операторы и операнды просматриваются последовательно слева направо. Всякий раз, когда просматривается операнд, в стек заносится его имя, а когда встречается операция, генерируются команды для ее выполнения. При этом в качестве описаний операндов используются два верхних описания в стеке; затем эти два описания заменяются описанием результата. При этом необходимо сформировать временное имя Ti, которое заносится в стек. На практике стек можно отобразить на одномерный массив S(1), S(2), …, S(n). Для указания вершины стека можно использовать индекс i. При записи в стек указатель вершины будет сдвигаться в сторону конца массива, при чтении из стека указатель вершины будет перемещаться в сторону начала массива (рис. 14).
          </p>
          <div className="image-container">
            <img src="/images/рис 14.png" alt="Рисунок 14" className="chapter-image" />
            <p className="image-caption">Рис. 14</p>
          </div>
          <p>
            Для обработки доступен только элемент S(i), т.е. вершина стека. Значение i = 0 перед чтением из стека служит признаком того, что стек пуст, а значение i = n перед записью в стек – признаком того, что стек переполнен.
          </p>
        </section>

        <div className="questions-section">
          <button 
            className="questions-btn"
            onClick={() => setShowQuestions(!showQuestions)}
          >
            {showQuestions ? '▼' : '▶'} Контрольные вопросы
          </button>
          
          {showQuestions && (
            <div className="questions-content">
              <ol className="questions-list">
                {questions.map((question, index) => (
                  <li key={index}>{question}</li>
                ))}
              </ol>
            </div>
          )}
        </div>
        
        <div className="chapter-navigation">
          <Link to="/" className="btn">На главную</Link>
        </div>
      </div>
    </div>
  )
}

export default Chapter2

