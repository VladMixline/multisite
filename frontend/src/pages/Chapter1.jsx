import { useState } from 'react'
import { Link } from 'react-router-dom'
import './Chapter1.css'

function Chapter1() {
  const [showQuestions, setShowQuestions] = useState(false)
  
  const questions = [
    "Что такое синтаксис языка?",
    "Что такое семантика языка?",
    "Что определяет грамматика языка?",
    "Что такое формальный язык?",
    "Для чего используются синтаксические деревья?",
    "Как называется транслятор, у которого функциональное назначение – перевод программы с языка низкого уровня в машинные коды?"
  ]
  return (
    <div className="chapter1">
      <div className="container">
        <nav className="breadcrumb">
          <Link to="/">Главная</Link> / 1. ТЕОРИЯ ФОРМАЛЬНЫХ ГРАММАТИК И ЯЗЫКОВ
        </nav>
        
        <h1>1. ТЕОРИЯ ФОРМАЛЬНЫХ ГРАММАТИК И ЯЗЫКОВ</h1>
        
        <div className="chapter-plan">
          <h2>План:</h2>
          <ol>
            <li>Грамматика.</li>
            <li>Формальные определения грамматики и языка.</li>
            <li>Классификация грамматик.</li>
            <li>Синтаксические деревья.</li>
          </ol>
          <p className="keywords">
            <strong>Ключевые слова:</strong> синтаксис языка, семантика языка, грамматика, формальный язык, синтаксический язык.
          </p>
        </div>

        <section className="chapter-section">
          <h2>1.1. ГРАММАТИКА</h2>
          <p>
            Грамматика языка является формальным описанием его синтаксиса или формы, в которой записаны отдельные предложения программы или вся программа. Грамматика не описывает семантику или значения различных предложений.
          </p>
          <p>
            В качестве иллюстрации разницы между синтаксисом и семантикой рассмотрим два предложения:
          </p>
          <p className="code-example">
            i := j + k и i := x + y ,
          </p>
          <p>
            где x, y являются действительными переменными, а i, j, k целыми.
          </p>
          <p>
            Эти два предложения имеют одинаковый синтаксис. Оба являются операторами присваивания. Но с точки зрения семантики, эти предложения разные, так как компилируются в совершенно различные последовательности машинных команд.
          </p>
          <p>
            В первом случае складываются целые переменные j и k и результат присваивается переменной i.
          </p>
          <p>
            Во втором случае необходимо сложить вещественные переменные x и y, а результат преобразовать к целому виду и полученное значение присвоить переменной i.
          </p>
          <p>
            В качестве примера мы будем использовать программу на языке Паскаль, изображённую на рис. 1, однако обсуждаемые концепции и подходы приложимы и к другим языкам. Существует несколько различных форм записи грамматик, среди которых мы рассмотрим форму Бекуса–Наура (БНФ). БНФ не самое мощное из известных средств описания синтаксиса. Однако эта форма достаточно проста, широко используется и предоставляет достаточные для большинства приложений средства.
          </p>
          <p>
            На рис. 2 изображена одна из возможных грамматик БНФ для очень узкого подмножества языка Паскаль.
          </p>
          <div className="image-container">
            <img src="/images/рис 1.png" alt="Рисунок 1" className="chapter-image" />
            <p className="image-caption">Рис. 1</p>
          </div>
          <p>
            Грамматика БНФ состоит из множества правил вывода, каждое из которых определяет синтаксис некоторой конструкции языка. Рассмотрим, например, правило 8 на рис. 2:
          </p>
          <p className="code-example">
            &lt;присваивание&gt; → ид := &lt;арифметическое выражение&gt;
          </p>
          <div className="image-container">
            <img src="/images/рис 2.png" alt="Рисунок 2" className="chapter-image" />
            <p className="image-caption">Рис. 2</p>
          </div>
          <p>
            Это определение оператора присваивания языка ПАСКАЛЬ, обозначенное как &lt;присваивание&gt;. Символ "→" можно читать как "является по определению". С левой стороны от этого символа находится определяемая конструкция языка (в нашем случае &lt;присваивание&gt;), а с правой – описание синтаксиса этой конструкции. Строки символов, заключенные в угловые скобки, называются нетерминальными символами. Они составляют синтаксические классы языка. Символы, не заключённые в угловые скобки, называются терминальными символами. Они составляют лексические классы или алфавит языка. В рассматриваемом примере нетерминальными символами являются &lt;присваивание&gt; и &lt;арифметическое выражение&gt;, а терминальными – ид и :=. Таким образом, это правило определяет, что конструкция &lt;присваивание&gt; состоит из идентификатора (терминал ид), символа алфавита :=, за которым следует конструкция &lt;арифметическое выражение&gt;. Пробелы для написания грамматики не существенны и вставляются только для наглядности.
          </p>
          <p>
            Для распознавания нетерминального символа &lt;присваивание&gt; необходимо, чтобы существовало определение для нетерминального символа &lt;арифметическое выражение&gt;. Это определение даётся правилом 9 на рис. 2:
          </p>
          <p className="code-example">
            &lt;арифметическое выражение&gt; → &lt;слагаемое&gt;/&lt;арифметическое выражение&gt; +/- &lt;слагаемое&gt;
          </p>
          <p>
            Это правило предполагает две возможности, разделённые символом /. Первая состоит в том, что &lt;арифметическое выражение&gt; состоит из одной конструкции &lt;слагаемое&gt;. Другой вариант заключается в том, что &lt;арифметическое выражение&gt; состоит из конструкции &lt;арифметическое выражение&gt;, за которым следует знак + или –, за которым следует конструкция &lt;слагаемое&gt;. Это правило является рекурсивным, т.е. конструкция &lt;арифметическое выражение&gt; определяется рекурсивно в терминах себя самой. В соответствии с этим правилом нетерминальным символом &lt;арифметическое выражение&gt; является любая последовательность из одного или более слагаемых, разделённых знаками + или –.
          </p>
        </section>

        <section className="chapter-section">
          <h2>1.2. ФОРМАЛЬНЫЕ ОПРЕДЕЛЕНИЯ ГРАММАТИКИ ЯЗЫКА</h2>
          <p>
            Прежде, чем приступать к реализации транслирующих программ, необходимо определить некоторые понятия.
          </p>
          <p>
            Алфавит языка – непустое, конечное множество символов. Например, пусть алфавит языка включает три символа: {'{'}a, b, c{'}'}.
          </p>
          <p>
            Предложение – непустое конечное множество символов алфавита. Например, из трёх символов алфавита мы можем получить бесконечное количество предложений: aabb, abcc, bac, bca и т.д.
          </p>
          <p>
            Грамматика устанавливает правила вывода синтаксически правильных предложений из всех возможных. Формально грамматика G определяется как четвёрка объектов: (N, T, P, S), где N – множество нетерминальных символов, образующее синтаксические классы языка; T – множество терминальных символов, образующее алфавит языка; P – множество правил переписывания (например, в форме Бэкуса–Наура); S – начальный нетерминальный символ грамматики, с которого начинается разбор любого предложения языка.
          </p>
          <p>
            Языком L над грамматикой G называется множество предложений, состоящих из терминальных символов T, выводимых с помощью правил P, начиная с начального нетерминального символа S.
          </p>
        </section>

        <section className="chapter-section">
          <h2>1.3. КЛАССИФИКАЦИЯ ГРАММАТИК</h2>
          <p>
            Одна из классификаций грамматик связана с видом правил переписывания P. По этой классификации грамматики разделяют на регулярные, контекстно-свободные, контекстно-зависимые и без ограничений.
          </p>
          <p>
            Грамматика называется регулярной, если правила переписывания имеют вид: A→cB или A→c, где A, B – нетерминальные символы; c – терминальный символ грамматики.
          </p>
          <p className="example">
            <strong>Пример.</strong> G1=({'{'}'S{'}'}, {'{'}0,1{'}'}, P={'{'}S→0S/1S/0/1{'}'}, S}).
          </p>
          <p>
            Грамматика называется контекстно-свободной, если правила переписывания имеют вид: A→w, где A – нетерминальный символ, w∈(N∪T) – объединение нетерминальных и терминальных символов грамматики.
          </p>
          <p className="example">
            <strong>Пример.</strong> G2=({'{'}'A,Z{'}'}, {'{'}a,*, +, (, ){'}'}, P={'{'}A→Z/A+Z, Z→a/Z*a/(A){'}'}, A}).
          </p>
          <p>
            Грамматика называется контекстно-зависимой, если правила переписывания имеют вид: k→w, где k, w∈(N∪T) – объединение нетерминальных и терминальных символов грамматики, причём |k|≤|w|.
          </p>
          <p className="example">
            <strong>Пример.</strong> G3=({'{'}'S,B,C{'}'}, {'{'}a,b,c{'}'}, P={'{'}S→aSBC/abC, CB→BC, bB→bb, bC→bc, cC→cc{'}'}, S}).
          </p>
          <p>
            И, наконец, грамматика без ограничений не содержит никаких ограничений в правилах переписывания, которые, в том числе, допускают переход в пустое множество.
          </p>
          <p>
            Грамматика большинства языков программирования записывается в терминах контекстно-свободных грамматик.
          </p>
        </section>

        <section className="chapter-section">
          <h2>1.4. СИНТАКСИЧЕСКИЕ ДЕРЕВЬЯ</h2>
          <p>
            Результат анализа исходного предложения в терминах грамматических конструкций удобно представлять в виде дерева. Такие деревья принято называть синтаксическими.
          </p>
          <p>
            На рисунке 3, а изображено дерево грамматического разбора для предложения read(a) с помощью правил 12 и 4 грамматики, представленной на рис. 2.
          </p>
          <p>
            На рисунке 3, б приведено синтаксическое дерево разбора предложения rez:=sum div100–a*a. Это дерево выводится с помощью правил 8, 9, 10, 11 грамматики, представленной на рис. 2.
          </p>
          <div className="image-container">
            <img src="/images/рис 3.png" alt="Рисунок 3" className="chapter-image" />
            <p className="image-caption">Рис. 3</p>
          </div>
          <p>
            Таким образом, рассматривая правила грамматики, начиная с начального, можно построить синтаксическое дерево для всей программы, представленной на рис. 1.
          </p>
        </section>

        <div className="questions-section">
          <button 
            className="questions-btn"
            onClick={() => setShowQuestions(!showQuestions)}
          >
            {showQuestions ? '▼' : '▶'} Контрольные вопросы
          </button>
          
          {showQuestions && (
            <div className="questions-content">
              <ol className="questions-list">
                {questions.map((question, index) => (
                  <li key={index}>{question}</li>
                ))}
              </ol>
            </div>
          )}
        </div>
        
        <div className="chapter-navigation">
          <Link to="/" className="btn">На главную</Link>
        </div>
      </div>
    </div>
  )
}

export default Chapter1

