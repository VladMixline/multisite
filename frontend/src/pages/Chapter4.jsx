import { useState } from 'react'
import { Link } from 'react-router-dom'
import './Chapter4.css'

function Chapter4() {
  const [showQuestions, setShowQuestions] = useState(false)
  
  const questions = [
    "В чём заключается основная цель фазы оптимизации?",
    "Какие существуют критерии эффективности для оптимизации кода?",
    "Преобразования, осуществляемые на фазе оптимизации, должны приводить к программе, эквивалентной исходной или иной?",
    "Что такое машинно-зависимая оптимизация?",
    "Что такое машинно-независимая оптимизация?",
    "Что такое оптимизация константных вычислений?",
    "В чём принцип уменьшения силы операций?",
    "Что такое общие подвыражения?",
    "Что такое инварианты циклов?"
  ]

  return (
    <div className="chapter4">
      <div className="container">
        <nav className="breadcrumb">
          <Link to="/">Главная</Link> / 4. ОПТИМИЗАЦИЯ КОДА
        </nav>
        
        <h1>4. ОПТИМИЗАЦИЯ КОДА</h1>
        
        <div className="chapter-plan">
          <h2>План:</h2>
          <ol>
            <li>Машинно-зависимая оптимизации.</li>
            <li>Машинно-независимая оптимизация.</li>
            <li>Методы оптимизации кода.</li>
          </ol>
          <p className="keywords">
            <strong>Ключевые слова:</strong> общие подвыражения, инварианты цикла.
          </p>
        </div>

        <section className="chapter-section">
          <p>
            Рассмотрим некоторые методы машинно-независимой оптимизации кода. Мы не будем стремиться к детальному описанию какого-либо из этих методов. Вместо этого мы дадим словесное описание и проиллюстрируем основные понятия примерами. Алгоритмы и детали, касающиеся этих методов, можно найти в работах [2, 3].
          </p>
          <p>
            Одним из важных источников оптимизации кода является удаление общих подвыражений, которые встречаются в нескольких местах программы и вычисляют одно и то же выражение. Рассмотрим, например, предложение:
          </p>
          <div className="code-block">
            <pre>{`VAR x,y: ARRAY [1..10,1..10] OF INTEGER;
… FOR i := 1 TO 10 DO
x [ i , 2*j-1 ] := y [ i , 2*j ];
…`}</pre>
          </div>
          <p>
            Выражение 2*j является общим подвыражением. Оптимизирующий компилятор должен только один раз сгенерировать код, вычисляющий это умножение, и использовать его результат в обоих местах.
          </p>
          <p>
            Общие подвыражения обычно обнаруживаются при анализе промежуточной формы представления программы (рис. 19). Следует отметить, что в первоначальном варианте требуется выполнить 161 операцию.
          </p>
          <div className="image-container">
            <img src="/images/рис 19.png" alt="Рисунок 19" className="chapter-image" />
            <p className="image-caption">Рис. 19</p>
          </div>
          <p>
            Если мы исследуем эту последовательность четвёрок, то обнаружим, что четвёрки 5 и 11 совпадают, за исключением имени получаемого промежуточного результата. Обратите внимание, что операнд j не меняет своего значения между четвёрками 5 и 11.
          </p>
          <p>
            Невозможно достичь четвёрки 11, не проходя предварительно четвёрку 5, поскольку они расположены на одном линейном участке.
          </p>
          <p>
            Таким образом, четвёрки 5 и 11 вычисляют одно и тоже значение. Это означает, что мы можем удалить четвёрку 11 и заменить любые обращения к её результату (i9) на обращение к переменной i3, которая является результатом четвёрки 5. Эта модификация позволяет избежать дублирования вычислений подвыражения 2*j, которое мы выделили как общее подвыражение при анализе исходной программы.
          </p>
          <p>
            После замены i3 на i10 мы обнаружим, что четвёрки 6 и 12 также совпадают, за исключением имени результата. Следовательно, мы можем удалить четвёрку 12 и заменить переменную i11 всюду, где она используется на переменную i4. Аналогично четвёрки 10 и 11 также могут быть удалены, поскольку они эквивалентны четвёркам 3 и 4. В результате получим новую последовательность четвёрок (рис. 20), которая предполагает выполнение всего 121 операции.
          </p>
          <div className="image-container">
            <img src="/images/рис 20.png" alt="Рисунок 20" className="chapter-image" />
            <p className="image-caption">Рис. 20</p>
          </div>
          <p>
            Обратите внимание, что общее количество четвёрок сокращено с 17 до 13. Поскольку операции во всех используемых здесь четвёрках займут, вероятно, примерно одинаковое время на обычном компьютере, то мы также сократим общее время выполнения программы.
          </p>
          <p>
            Другим источником оптимизации кода является удаление инвариантов цикла. Так называется подвыражение внутри цикла, результирующие значения которых не изменяются внутри цикла при переходе от одной итерации к другой. Таким образом, эти значения могут быть вычислены только один раз перед входом в тело цикла вместо того, чтобы вычислять их заново перед каждой итерацией. Поскольку для большинства программ основное время работы приходится на выполнение циклов, экономия времени от подобной оптимизации может быть весьма существенной.
          </p>
          <p>
            <strong>Примечание:</strong> необходимо выполнить 94 операции.
          </p>
          <p>
            Примером инварианта цикла является вычисление выражения 2*j. Результат вычисления этого выражения зависит только от операнда j, значение которого не изменяется во время выполнения цикла. Таким образом, мы можем поместить четвёрку 5 непосредственно перед началом выполнения цикла. Аналогичные соображения относительно четвёрок 6 и 7.
          </p>
          <p>
            В результате получим новую последовательность четвёрок (рис. 21). Общее количество четвёрок остаётся тем же, но количество четвёрок в цикле уменьшилось с 12 до 9. Каждое выполнение предложения FOR вызывает десятикратное выполнения тела цикла. Это означает, что общее количество операций, необходимых для выполнения FOR, сократилось со 121 до 94.
          </p>
          <div className="image-container">
            <img src="/images/рис 21.png" alt="Рисунок 21" className="chapter-image" />
            <p className="image-caption">Рис. 21</p>
          </div>
          <p>
            Общее количество операций, приходящихся на одно выполнение предложения FOR, по сравнению с начальным вариантом сократилось со 161 до 94, что существенно уменьшило выполнение программы.
          </p>
          <p>
            Существуют также и более тонкие методы обработки общих подвыражений и инвариантов цикла, чем описанные выше. Можно ожидать, что благодаря этим методам может быть получен ещё более оптимизированный вариант кода.
          </p>
        </section>

        <div className="questions-section">
          <button 
            className="questions-btn"
            onClick={() => setShowQuestions(!showQuestions)}
          >
            {showQuestions ? '▼' : '▶'} Контрольные вопросы
          </button>
          
          {showQuestions && (
            <div className="questions-content">
              <ol className="questions-list">
                {questions.map((question, index) => (
                  <li key={index}>{question}</li>
                ))}
              </ol>
            </div>
          )}
        </div>
        
        <div className="chapter-navigation">
          <Link to="/" className="btn">На главную</Link>
        </div>
      </div>
    </div>
  )
}

export default Chapter4


