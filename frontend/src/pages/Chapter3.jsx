import { useState } from 'react'
import { Link } from 'react-router-dom'
import './Chapter3.css'

function Chapter3() {
  const [showQuestions, setShowQuestions] = useState(false)
  
  const questions = [
    "В каком типе организации таблиц символов поиск элемента требует сравнения с каждым элементом таблицы, пока не будет найден подходящий?",
    "Сколько (максимум) сравнений бинарный поиск требует для n = 128 элементов?",
    "Какой метод рехеширования состоит в том, что принимаем p1 = 1, p2 = 2, p3 = 3 и т.д.?",
    "В этом типе рехеширования принимается pi = i*h, где h – исходный хеш-индекс.",
    "Какое поле в методе цепочек используется для того, чтобы связать в цепочку элементы, для которых хеширование символа приводит к тому же самому указателю?",
    "Для чего нужна кодировочная таблица?",
    "Для чего служит таблица символов?",
    "Как организуется таблица символов?",
    "В чём состоит метод бинарного поиска?",
    "Что такое хеширование?",
    "Как работает метод цепочек?",
    "Какие известны способы рехеширования?",
    "Как сравниваются известные способы организации таблиц символов?",
    "В чём суть методов бинарного поиска и упорядоченных вставок?",
    "Каковы достоинства хеш-адресации и каковы её недостатки?",
    "Какие известны способы рехеширования?",
    "В чём преимущество метода цепочек по сравнению с рехешированием?",
    "Какая информация хранится в таблице символов?",
    "Как записать информацию о переменных?"
  ]

  return (
    <div className="chapter3">
      <div className="container">
        <nav className="breadcrumb">
          <Link to="/">Главная</Link> / 3. ОРГАНИЗАЦИЯ ТАБЛИЦ СИМВОЛОВ
        </nav>
        
        <h1>3. ОРГАНИЗАЦИЯ ТАБЛИЦ СИМВОЛОВ</h1>
        
        <div className="chapter-plan">
          <h2>План:</h2>
          <ol>
            <li>Способы организации таблиц символов.</li>
            <li>Неупорядоченные и упорядоченные таблицы.</li>
            <li>Хеш-адресация.</li>
            <li>Рехеширование.</li>
            <li>Метод цепочек.</li>
          </ol>
          <p className="keywords">
            <strong>Ключевые слова:</strong> таблица символов, поиск, коллизия.
          </p>
        </div>

        <section className="chapter-section">
          <h2>3.1. СПОСОБЫ ОРГАНИЗАЦИИ ТАБЛИЦ СИМВОЛОВ</h2>
          <p>
            Проверка правильности семантики и генерация кода требуют знания характеристик идентификаторов, используемых в программе на исходном языке. Эти характеристики выясняются из описаний и из того, как идентификаторы используются в программе. Вся информация накапливается в таблицах символов.
          </p>
          <p>
            Таблицы всех типов имеют общий вид (табл. 6). В нашем случае аргументами таблицы являются символы или идентификаторы, а значениями – их характеристики. Когда компилятор начинает трансляцию исходной программы, таблица символов пуста или содержит только несколько элементов для служебных слов и стандартных функций. В процессе компиляции для каждого нового идентификатора элемент добавляется только один раз, но поиск ведётся всякий раз, когда встречается этот идентификатор. Так как на этот процесс уходит много времени, важно выбрать такую организацию таблиц, которая допускала бы эффективный поиск.
          </p>
          <div className="image-container">
            <img src="/images/таблица 6.png" alt="Таблица 6" className="chapter-image" />
            <p className="image-caption">Таблица 6</p>
          </div>
          <div className="image-container">
            <img src="/images/таблица 7.png" alt="Таблица 7" className="chapter-image" />
            <p className="image-caption">Таблица 7</p>
          </div>
          <p>
            Простейший способ организации таблицы состоит в том, чтобы добавлять элементы в порядке их поступления без каких-либо попыток упорядочения. Поиск в этом случае требует сравнения с каждым элементом таблицы, пока не будет найден подходящий. Для таблицы, содержащей N элементов, в среднем будет выполнено N/2 сравнений. Если N велико, такой способ неэффективен. Поиск может быть выполнен более эффективно, если элементы таблицы упорядочены согласно некоторому естественному порядку аргументов. В нашем случае, когда аргументами являются строки символов, наиболее естественным является упорядочение по алфавиту. Эффективным методом поиска в упорядоченном списке является так называемый бинарный поиск. Сортировка таблицы производится методом упорядоченных вставок.
          </p>
          <p>
            Наиболее эффективный и широко применяемый в компиляторах метод при работе с таблицами символов – хеш-адресация. Механизм расстановки состоит из таблицы и хеш-функции (табл. 7). Таблица состоит из N элементов, где N заранее фиксировано. Метод хеш-адресации заключается в преобразовании символа в индекс элемента в таблице. Индекс получается хешированием символа, т.е. выполнением над ним некоторых операций. Если в процессе компиляции встретился объект а, то для поиска его в таблице можно воспользоваться следующим алгоритмом: если объект уже встречался ранее, то h(а) – ячейка в таблице, в которой хранится а. Если объект а ранее не встречался, то h(а) – пустая ячейка, в которую заносится информация для а.
          </p>
          <p>
            Возникает, однако, затруднение, если результаты хеширования двух разных символов совпадают. Это называется коллизией. Очевидно, в данной позиции таблицы может быть помещён только один из этих символов, так что мы должны найти свободное место для второго. Желательно иметь такую хеш-функцию, которая распределяла бы объекты равномерно по всей таблице, так чтобы коллизии не возникали слишком часто. Но избежать их совсем практически не удаётся, поэтому разработчику компилятора следует предусмотреть способы решения задачи коллизии. Существуют два таких способа – рехеширование и метод цепочек.
          </p>
        </section>

        <section className="chapter-section">
          <h2>3.2. МЕТОД ЦЕПОЧЕК</h2>
          <p>
            Метод цепочек использует хеш-таблицу, элементы которой первоначально равны 0, собственно таблицу символов, вначале пустую, и указатель УК, который указывает на текущее положение последнего элемента в таблице символов. Элементы таблицы символов имеют дополнительное поле СНАIN, которое может содержать 0 или адрес другого элемента таблицы символов. Начальное состояние таблицы приведено на рис. 15.
          </p>
          <div className="image-container">
            <img src="/images/рис 15.png" alt="Рисунок 15" className="chapter-image" />
            <p className="image-caption">Рис. 15</p>
          </div>
          <p>
            Хеш-функция, применённая к символу, даёт индекс указателя в хеш-таблице. Указатель либо равен 0, либо указывает на первый элемент таблицы символов с данным значением хеш-функции. Поле СНАIN каждого элемента используется для того, чтобы связать в цепочку элементы, для которых хеширование символа приводит к тому же самому указателю. Например, в таблицу необходимо записать символ S1. Функция хеширования вырабатывает адрес элемента хеш-таблицы, например 4. Содержимое этой ячейки равно 0. Тогда выполняется следующее:
          </p>
          <ol>
            <li>Прибавляем 1 к УК.</li>
            <li>Вносим элемент (S1, значение, 0) в позицию таблицы символов, на которую указывает УК.</li>
            <li>Заносим содержимое УК. в указатель 4 хеш-таблицы.</li>
            <li>Пока поступают символы, хеширование которых даёт индексы разных указателей, они заносятся в таблицу аналогичным образом. Так, если мы записываем в таблицу символы S2, S3, S4, хеширование которых даёт ссылки на указатели 1, 3, 6, таблица примет вид, представленный на рис. 16.</li>
          </ol>
          <div className="image-container">
            <img src="/images/рис 16.png" alt="Рисунок 16" className="chapter-image" />
            <p className="image-caption">Рис. 16</p>
          </div>
          <p>
            В конце концов, поступит символ S5, который ссылается на указатель, использовавшийся ранее, например на 6. Вот здесь и начинает действовать поле CHAIN. Символ S5 записывается в таблицу символов и добавляется к концу цепочки для этого указателя (рис. 17).
          </p>
          <div className="image-container">
            <img src="/images/рис 17.png" alt="Рисунок 17" className="chapter-image" />
            <p className="image-caption">Рис. 17</p>
          </div>
          <p>
            Внесем в таблицу символы S6, S7, S8, которые ссылаются на указатели 4, 3, 3 соответственно (рис. 18).
          </p>
          <div className="image-container">
            <img src="/images/рис 18.png" alt="Рисунок 18" className="chapter-image" />
            <p className="image-caption">Рис. 18</p>
          </div>
        </section>

        <div className="questions-section">
          <button 
            className="questions-btn"
            onClick={() => setShowQuestions(!showQuestions)}
          >
            {showQuestions ? '▼' : '▶'} Контрольные вопросы
          </button>
          
          {showQuestions && (
            <div className="questions-content">
              <ol className="questions-list">
                {questions.map((question, index) => (
                  <li key={index}>{question}</li>
                ))}
              </ol>
            </div>
          )}
        </div>
        
        <div className="chapter-navigation">
          <Link to="/" className="btn">На главную</Link>
        </div>
      </div>
    </div>
  )
}

export default Chapter3


